---TOPICS:
- soft: Burp Suite community edition
- inny soft?
HTTP:
- http HEAD nie pobiera ciala, przyspierza silowe szukanie plikow i inne testy
- szczególnie niebezpieczna bywa metoda PUT (często jest ona domyślnie wyłączona), umożliwiająca tworzenie plików na serwerze HTTP
- blokowanie na serwerze metody PUT (pUT, puT itd), testowanie
- Referer header jest wysyłany niezaszyfrowany nawet jak korzystamy z HTTPS. Zabezpieczenie: Referrer-Policy: no-referrer
- SQL Injection, zlokalizowana 22 marca 2019 roku w nagłówku User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ⤦
Chrome/55.0.2883.87'XOR(if(now()=sysdate(),sleep(5*5),0))OR' - 
- Path Traversal: Accept: ../../../../../../../../../../etc/passwd{{
- parametry, często można manipulować, wysyłane w url GET
- parametry też się wysyła w ciele POST
- manipulacja kontentem, żądanie POST: application/x-www-form-urlencoded
- manipulacja kontentem, POST: multipart/form-data - WAF Bypass Techniques – Using HTTP Standard and Web Servers’ Behaviour
- podatności z GET + ciało
Burp:
- zakładce proxy można je skonfigurować i przechwytywać (intercept) zapytania i odpowiedzi, konfig w Opcjach
- do repeatera można skopiować żądanie
- intruder służy do enumeracji parametrów żądania //COMMUNITY EDITION IS LIMITED
- comparer służy do porównywania żądzań lub odpowiedzi
- decoder służy do dekodowanie z BASE64 lub innego formatu
- sequencer służy do analizy entropii tokena - spr identyfikatory sesji
- HTTPS z Burp -> 127.0.0.1:8080 w przeglądarce -> save cert -> dodanie cert do przeglądarki (coś hurde fajans nie działa. do spr ostatni certyfikat PortSwigger CA)
- socks proxy host jedt do wykorzystania proxy
Do najpopularniejszych (nagłówków) – związanych z bezpieczeństwem – należy zaliczyć:
- HTTP Strict Transport Security (HSTS)
- Content-Security-Policy
- X-Frame-Options
- X-Content-Type-Options
- Referrer-Policy
- Feature-Policy
- Access-Control-Allow-Origin
Chrome / Firefox dev tools:
- szukanie iframe
- endpointy API
- odwracanie minifikacji kodu JS w zakładce Sources
- zakładka Elements zawiera też kod dodany dynamicznie przez JS
- podejrzenie ciasteczek
- debugger pozwala podejrzenie wartości w kodzie
- Punkty wejścia i wykonania kodu (sources oraz execution sinks) <- do ogarnięcia: Na kanale @LiveOverflow w serwisie YouTube
Hasła:
- atak słownikowy
- atak siłowy
- atak mieszany (słownikowy + siłowy)
- atak tęczowe tablice
- listy najczęściej używanych haseł
- unimożliwiać użycie łatwego hasła
- uniemożliwić użycie hasłą takeigo samego jak login / email
- utrudnianie powtazralności ataków (opóźnienia, spowolnienia, captcha)
- wymuszanie znaków specjalnych, cyfr, capsów
- najbezpieczniej zapisane hasło: sól (indywidualnie), pieprz (osobne źródło), hashowanie SHA512
Rekonesans:
- lokalizacja serwerów nmap (urządzenie do skanowania portów) "W tym przypadku realizujemy sprawdzenie wszystkich portów TCP (0–65535) oraz skanowanie z wersjonowaniem (-sV). Możemy również posłużyć się skryptem http-headers, który dodatkowo wyświetli nagłówki odpowiedzi HTTP."
- szukanie domen powiązanych i subdomen za pomocą: google/bing/yandex, serwisów i API, szukanie po IP, metoda słownikowa, wyszukiwarki Certificate Transparency logs, Projekt Sonar
- wsteczna inżynieria aplikacji mobilnych w poszukiwaniu domen, linków itd
- domeny wirtualne (?)
Ukryte katalogi i pliki:
- szukanie katalogu .git, .gitignore lub .svn
- Jeżeli programista pozostawił na serwerze folder .git, nic nie stoi na przeszkodzie, aby odczytać zawartość dowolnego pliku, nawet jeśli nie mamy uprawnień do pobrania całego repozytorium, poleceniem git clone czy git checkout
- Jak zatem sprawdzić, czy folder .git/.svn znajduje się na serwerze? Wystarczy sprawdzić, czy adres URL w postaci np. http://adresserwisu/.git/ zwróci odpowiedź HTTP z kodem innym niż 404 Not Found.
- folder .idea i workspace.xml, inne
XSS (Cross-Site Scripting):
- test1: w forularz wpisanie <u>test (spr czy enkoduje)
- test2: <script>alert(1)</script>
- reflected XSS - wyświetlany w parametrze odpowedzi
- persistent XSS - zapisanie skryptu w bazie danych (np blog)
- DOM-based XSS
- za pomocą XSS jesteśmy w stanie odczytać dowolne dane w kontekście zalogowanego użytkownika
- możliwość wykonania dowolnej akcji w kontekście zalogowanego użytkownika
- Innymi słowy, XSS pozwala na przejęcie dostępu do sesji użytkownika
- Istnieją również narzędzia, takie jak BeEF3, które zawierają gotowe moduły pozwalające na dalsze wykorzystanie (post-eksploitację) XSS
- dla najpopularniejszych wariantów XSS zabezpieczeniem jest enkodowanie
Konteksty XSS:
- WSTRZYKNIĘCIE W ZAWARTOŚCI TAGU: <div><img src onerror=alert(1)></div>
- WSTRZYKNIĘCIE W ZAWARTOŚCI ATRYBUTU: <div class="" onmouseover=alert(1) "></div>; <div class=""><script>alert(1)</script>"></div>
- WSTRZYKNIĘCIE W ZAWARTOŚCI ATRYBUTU BEZ CUDZYSŁOWÓW/APOSTROFÓW: <div class=x onclick=alert(1)></div>
- WSTRZYKNIĘCIE W ATRYBUCIE HREF: <a href="javascript:alert(1)"></a>
- WSTRZYKNIĘCIE W STRINGU WEWNĄTRZ KODU JS: <script>var username="";alert(1)//";</script>
- WSTRZYKNIĘCIE W ATRYBUCIE ZE ZDARZENIEM JS: <div onclick="change('&#39;);alert(1)//')">User1</div>
- WSTRZYKNIĘCIE W ATRYBUCIE HREF WEWNĄTRZ PROTOKOŁU JS: <a href="javascript:change('%27);alert(1)//')">CLICK</a>
Metody obrony przed XSS:
- Zamiana znaków specjalnych HTML na encje.
- Jeżeli aplikacja generuje dynamicznie HTML, lepiej wartości atrybutów umieszczać wewnątrz cudzysłowów/apostrofów
- Jeżeli użytkownik może w aplikacji podać adres URL, walidujmy, czy protokół w adresie to HTTP/HTTPS. Odrzucajmy wszystkie pozostałe.
- Enkodowanie wszystkich znaków niealfanumerycznych do postaci UTF-16, tj. \uXXXX.
- W przypadku zagnieżdżeń kontekstów należy pamiętać o odpowiedniej ochronie dla każdego z nich.
Podatności DOM XSS:
- Funkcje typu eval: zaleca się, by nie używać funkcji typu eval czy Function na danych pochodzących z niezaufanych źródeł (np. od użytkownika).
- Funkcje przyjmujące kod HTML: innerHTML, outerHTML, insertAdjacentHTML, document.write - należy pamiętać o enkodowaniu danych
- Funkcje przyjmujące adres URL: obecny adres URL strony (location), ciasteczka (document.cookie) czy komunikacja typu postMessage, fetch
- Najbardziej zalecana ochrona przed tego typu XSS to wydzielenie osobnej domeny (tzw. domeny sandboksowej), z której serwowane będą pliki wgrywane przez użytkowników.
- upload plików SVG i html jest zagrożeniem (mogą zawierać skrypty, po przejściu do URL pliku można aktywować skrypt)
- edytory tekstu są potencjalnym zagrożeniem, rozwiązaniem jest sanityzacja (oczyszczanie ze szkodliwych znaczników)
- istnieją typowe obejścia popularnych filtrów XSS
Content Security Policy (CSP)
- CSP może być wdrożony jako nagłówek HTTP (o nazwie Content-Security-Policy lub Content-Security-Policy-Report-Only), jak również jako element <meta> bezpośrednio w kodzie HTML
- Przede wszystkim należy mieć na uwadze, że CSP to mechanizm, który chroni jedynie przed skutkami podatności
- *-src: skąd mogą być ładowane zewnętrzne zasoby na stronie
- script-src: jakie skrypty mogą zostać załadowane na stronie
- base-uri: W praktyce zaleca się, by base-uri stosować zawsze – ustawiać je albo na wartość 'none', albo 'self'.
- block-all-mixed-content i upgrade-insecure-requests
- frame-ancestors: jest sposobem ochrony przed atakiem typu Clickjacking (niewidoczny <iframe>)
- plugin-types: Dyrektywa plugin-types w praktyce używana jest niezwykle rzadko. odchodzi się od używania pluginów (takich jak Flash czy aplety Javy).
- report-uri: Dyrektywa report-uri jest związana bezpośrednio z trybem raportowania w CSP
- sandbox: Użycie atrybutu sandbox pozwala zastosować dodatkowe ograniczenia na stronie docelowej
- raportowanie (report-uri) - CSP może też wysyłać raporty, jeśli jego polityka zablokuje załadowanie jakiegoś elementu na stronie.
- można wł/wył raportowanie
- Przykłady: Tabela 5. Przykładowe polityki CSP (książka Sekurak)
Obejście CSP:
- przez JSONP
- przez frameworki JS
- jak aplikacja korzysta z dużej ilości zewnętrznych skryptów, np google-analytics.com
CORS & SOP:
- Same-Origin Policy (SOP) - blokowanie ruchu z innych źródeł
- CORS umożliwia nam bezpieczne wykonywanie zapytań HTTP Cross-Origin.
- jeśli na serwerze można dokonać operacji zmieniających stan aplikacji za pomocą zapytań prostych, to w dalszym ciągu możliwy jest typowy atak CSRF (również tak jak w wersji oryginalnej – tagi <img> lub <form>)*. CORS, przez konieczność wstecznej kompatybilności, nie jest w stanie nas przed tym obronić.
Obejścia CORS i złe praktyki:
- Access-Control-Allow-Origin: *
- dla https://example.com atakujący może zarejestrować https://example.com.evil.com
- błędne regexy wprzy wykluczeniach
- nagłówek ACAO ustawionym na null, przeglądarki nie zaimplementowały
- CORS i Cache Poisoning
- stosowanie w aplikacji podatnych modułów
- XSS powoduje, że atakujący dostaje możliwość wywoływania dowolnych zapytań cross-origin, ponieważ… nie są one cross-origin, tylko same-origin
- JSON Hijacking
- side-channel
Cross-Site Request Forgery (XSRF, CSRF, OSRF):
- jest to zmuszenie przeglądarki ofiary do wykonania pewnej nieautoryzowanej akcji (wykonania żądania HTTP), a atakujący na cel bierze zalogowanego użytkownika*.
- przykład: napisanie na forum komentarza z tagiem <img src="url z parametrami">, admin po zalogowaniu się próbuje pobrać img, przeglądarka realizuje GET z url
- przykład: na swojej stronie atakujący umieszcza tag <img src="url z parametrami">, nakłąnia admina do wejścia, realizowany jest GET z url
- przykład: spreparowana strona posiada formularz POST który wysyła parametry na wybrany url
- Zastosowanie parametru _method w formularzu HTML - można próbować innych metod HTTP
- w urządzeniu sieciowym można próbować: <img src="http://admin:admin@192.168.10.1/reboot/">
Zabezpieczenia przed CSRF:
- losowe tokeny
- zmiana wszystkich żądań metodą GET (które zmieniają stan aplikacji) na POST.
- należy sprawdzić, czy nie można sztucznie zmienić w aplikacji żądania POST na żądanie GET (z parametrami przekazywanymi w URI)
- atrybut SameSite (Flaga SameSite) dodawany do ciasteczek
Server-Side Template Injection (SSTI):
- Aby możliwe było jej wykorzystanie, powinniśmy przetwarzać po stronie serwera szablony pochodzące od niezaufanych użytkowników
- dostarczając użytkownikowi możliwość stworzenia szablonu, dajemy mu tym samym prawo do dodania nowego kodu do naszej aplikacji!
- identyfikacja silnika najpierw
- sprawdzanie podatności: w takich przypadkach dobrze sprawdzają się np. proste wyrażenia arytmetyczne typu ${2*2}
- sprawdzanie podatności: przez ${ może zwróci błędy
Obrona przed SSTI:
- rezygacja z szablonów (przynajmniej częściowa)
- tylko zaufany użytkownik może edytować szablony
- bezpieczne silniki
- Sandboxing - możemy sprawdzić, czy mamy szczęście i czy dany silnik nie udostępnia trybu „bezpiecznego” lub „sandboxowanego”.
- Hardening - Ostatnią deską ratunku może być konfiguracja serwera
Server-Side Request Forgery (SSRF):
- Server-Site Request Forgery – czyli zmuszenie serwera do zainicjowania pewnej komunikacji sieciowej
Miejsca występowania SSRF:
- parametry HTTP przekazywane w żądaniu, których nazwy zawierają nazwy plików lub adresy URL
- Pliki XML: Najbardziej chyba znanym jest podatność XXE
- Document type definition (DTD)
- XInclude: Umożliwia on dołączenie do bazowego dokumentu XML innych plików
- SVG/XLink
- XSLT
- Inne formaty plików
- różne biblioteki
- Mechanizm uploadu
- inne protokoły niż HTTP
Podatność SQL Injection:
- 

---TODO:
- modify requests and responses with C# (how?)?
- intruder c# (simple url + request setup)?

---OWASP WEBSITES:
https://owasp.org/www-project-top-ten/
https://dvwa.co.uk/
https://www.youtube.com/watch?v=IWWYNDiwYOA
https://www.zaproxy.org/
https://www.youtube.com/watch?v=2_lswM1S264